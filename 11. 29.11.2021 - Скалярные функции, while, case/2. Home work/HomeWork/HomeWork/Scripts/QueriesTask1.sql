-- Задача 1. Разработайте, пожалуйста, скрипт T-SQL для решения следующих задач,
-- исходные данные формируйте при помощи генератора случайных чисел, задачу Case12 
-- реализуйте в цикле, где код элемента меняется от 1 до 4, не используйте скалярную
-- функцию при решении Case12

-- •	Case12. Элементы окружности пронумерованы следующим образом: 1 – радиус R,
--		2 – диаметр D = 2·R, 3 – длина L = 2·π·R, 4 – площадь круга S = π·R2. Дан 
--		номер одного их этих элементов и его значение. Вывести значения остальных 
--		элементов данной окружности (в том же порядке). 

-- диапазон для генерации
declare @lo int = 5, @hi int = 15;

-- генерация числа
declare @num float = Rand() * (@hi - @lo) + @lo;

-- радиус, диаметр, длина, площадь круга
declare @r float, @d float, @l float, @s float;

-- счётчик итераций
declare @i int = 0;

-- количество итераций 
declare @n int = 4;

-- вывод шапки таблицы 
print(char(10) + 
	  char(9) + N'╔════╦════════════╦════════════╦════════════╦════════════╦════════════╗' + char(10) +
	  char(9) + N'║ N  ║  Значение  ║  Радиус    ║  Диаметр   ║   Длина    ║  Площадь   ║' + char(10) + 
	  char(9) + N'╠════╬════════════╬════════════╬════════════╬════════════╬════════════╣');

-- обработка 
while @i < @n begin

	-- получение радиуса 
	set @r = case @i 
		when 0 then @num
		when 1 then @num / 2
		when 2 then @num / (2 * Pi())
		when 3 then Sqrt(@num / Pi())
		end;

	-- вычисление значений  
	set @d = @r * 2;
	set @l = 2 * Pi() * @r;
	set @s = Pi() * (@r * @r);

	-- вывод результата
print(char(9) + N'║ ' + str(@i + 1, 2) + 
				N' ║ ' + str(@num, 10, 4) + 
				N' ║ ' + str(@r, 10, 4) + 
				N' ║ ' + str(@d, 10, 4) + 
				N' ║ ' + str(@l, 10, 4) + 
				N' ║ ' + str(@s, 10, 4) + 
				N' ║');

	-- установка следующего элемента 
	set @num = case @i 
		when 0 then @d
		when 1 then @l
		when 2 then @s
		end;

	set @i += 1;

end;

-- вывод подвала таблицы
print(char(9) + N'╚════╩════════════╩════════════╩════════════╩════════════╩════════════╝');

go


-- •	Proc17. Описать функцию RootsCount(A, B, C) целого типа, определяющую 
--		количество корней квадратного уравнения A·x2 + B·x + C = 0 (A, B, C — вещественные 
--		параметры). С ее помощью найти количество корней для каждого из пяти квадратных 
--		уравнений с данными коэффициентами. Количество корней определять по значению 
--		дискриминанта: D = B2 − 4·A·C.

-- создание функции 
drop function if exists RootsCount;
go

create function RootsCount(@a float, @b float, @c float)
returns int
	begin
		declare @d float = (@b * @b) - 4 * @a * @c;

		return case 
			when @d > 0 then 2
			when @d = 0 then 1
			when @d < 0 then 0
			when @a = 0 then -1
			end;
	end;
go

-- диапазон для генерации
declare @lo int = -10, @hi int = 100;

-- числа для обработки
declare @a float, @b float, @c float;

-- количество корней
declare @amount int;

-- счётчик итераций
declare @i int = 0;

-- количество итераций
declare @n int = 5;

-- вывод шапки таблицы 
print(char(10) + 
	  char(9) + N'╔════╦════════════╦════════════╦════════════╦═══════════════════════╗' + char(10) +
	  char(9) + N'║ N  ║  Число A   ║  Число B   ║  Число C   ║   Количество корней   ║' + char(10) + 
	  char(9) + N'╠════╬════════════╬════════════╬════════════╬═══════════════════════╣');

-- обработка чисел
while @i < @n begin

	-- генерация чисел
	set @a = Rand() * (@hi - @lo) + @lo;
	set @b = Rand() * (@hi - @lo) + @lo;
	set @c = Rand() * (@hi - @lo) + @lo;

	-- вычисление количества корней
	set @amount = dbo.RootsCount(@a, @b, @c);
	
	-- вывод результата
print(char(9) + N'║ ' + str(@i + 1, 2) + 
				N' ║ ' + str(@a, 10, 4) + 
				N' ║ ' + str(@b, 10, 4) + 
				N' ║ ' + str(@c, 10, 4) + 
				N' ║ ' + iif(@amount != -1, str(@amount, 21), N' Некорректные данные ')  +  
				N' ║');

	set @i += 1;
end;

-- вывод подвала таблицы
print(char(9) + N'╚════╩════════════╩════════════╩════════════╩═══════════════════════╝' + char(10));

go



-- •	Proc18. Описать функцию CircleS(R) вещественного типа, находящую площадь круга 
--		радиуса R (R — вещественное). С помощью этой функции найти площади пяти кругов с 
--		данными радиусами. Площадь круга радиуса R вычисляется по формуле S = π·R2. 

-- создание функции 
drop function if exists CircleS;
go

create function CircleS(@r float)
returns float
	begin
		return Pi() * (@r * @r);
	end;
go


-- диапазон для генерации
declare @lo int = 5, @hi int = 15;

-- радиус круга
declare @r float;

-- площадь круга
declare @s float;

-- счётчик итераций
declare @i int = 0;

-- количество итераций
declare @n int = 5;

-- вывод шапки таблицы 
print(char(10) + 
	  char(9) + N'╔════╦════════════╦════════════╗' + char(10) +
	  char(9) + N'║ N  ║   Радиус   ║  Площадь   ║' + char(10) + 
	  char(9) + N'╠════╬════════════╬════════════╣');

-- обработка 
while @i < @n begin

	-- генерация радиуса круга
	set @r = Rand() * (@hi - @lo) + @lo;

	-- вычисление площади круга
	set @s = dbo.CircleS(@r);
	
	-- вывод результата
print(char(9) + N'║ ' + str(@i + 1, 2) + 
				N' ║ ' + str(@r, 10, 4) + 
				N' ║ ' + str(@s, 10, 4) +
				N' ║');

	set @i += 1;
end;

-- вывод подвала таблицы
print(char(9) + N'╚════╩════════════╩════════════╝' + char(10));

go


-- •	Proc19. Описать функцию RingS(R1, R2) вещественного типа, находящую площадь кольца, 
--		заключенного между двумя окружностями с общим центром и радиусами R1, R2 (R1 и R2 —
--		вещественные, R1 > R2, при нарушении этого условия возвращайте -1). С ее помощью 
--		найти площади пяти колец, для которых даны внешние и внутренние радиусы. 
--		Воспользоваться формулой площади круга радиуса R: S = π·R2.

-- создание функции
drop function if exists RingS;
go

create function RingS(@r1 float, @r2 float)
returns float
	begin
		-- если правило о радиусах нарушено
		if @r1 > @r2 return -1;

		return Pi() * ((@r2 * @r2) - (@r1 * @r1));
	end;
go

-- диапазон для генерации
declare @lo int = 5, @hi int = 7;

-- внутренний и внешний радиусы
declare @r1 float, @r2 float;

-- площадь кольца
declare @s float;

-- счётчик итераций
declare @i int = 0;

-- количество итераций
declare @n int = 5;

-- вывод шапки таблицы 
print(char(10) + 
	  char(9) + N'╔════╦═══════════════════════╦═════════════════════╦════════════╗' + char(10) +
	  char(9) + N'║ N  ║   Радиус внутренний   ║   Радиус внешний    ║  Площадь   ║' + char(10) + 
	  char(9) + N'╠════╬═══════════════════════╬═════════════════════╬════════════╣');

-- обработка 
while @i < @n begin

	-- генерация внутреннего и внешнего радиуса круга
	set @r1 = Rand() * (@hi - @lo) + @lo;
	set @r2 = @r1 + (Rand() * (@hi - @lo) + @lo);

	-- вычисление площади кольца
	set @s = dbo.RingS(@r1, @r2);
	
	-- вывод результата
print(char(9) + N'║ ' + str(@i + 1, 2) + 
				N' ║ ' + str(@r1, 21, 4) + 
				N' ║ ' + str(@r2, 19, 4) +
				N' ║ ' + str(@s, 10, 4) +
				N' ║');

	set @i += 1;
end;

-- вывод подвала таблицы
print(char(9) + N'╚════╩═══════════════════════╩═════════════════════╩════════════╝' + char(10));

go

-- •	Proc28. Описать функцию IsPrime(N) логического типа, возвращающую TRUE, если целый
--		параметр N (> 1, при нарушении условия возвращать FALSE) является простым числом, 
--		и FALSE в противном случае (число, большее 1, называется простым, если оно не имеет 
--		положительных делителей, кроме 1 и самого себя). Дан набор из 10 целых случайных 
--		чисел, больших 1. С помощью функции IsPrime найти количество простых чисел в данном 
--		наборе.

-- создание функции
drop function if exists IsPrime;
go

create function IsPrime(@num int)
returns bit
	begin
		-- если число меньше или равно 1
		if @num <= 1 return 0;

		-- делитель
		declare @n int = 2;

		while @n <= @num / 2 begin
			
			-- если число делится без остатка
			if @num % @n = 0 return 0;
			
			-- увеличение делителя
			set @n += 1;

		end;

		return 1;
	end;
go


-- диапазон для генерации
declare @lo int = 1, @hi int = 10;

-- число
declare @num int;

-- результат
declare @result bit;

-- счётчик итераций
declare @i int = 0;

-- количество итераций
declare @n int = 10;

-- вывод шапки таблицы 
print(char(10) + 
	  char(9) + N'╔════╦════════════╦═══════════════╗' + char(10) +
	  char(9) + N'║ N  ║   Число    ║ Число простое ║' + char(10) + 
	  char(9) + N'╠════╬════════════╬═══════════════╣');

-- обработка 
while @i < @n begin

	-- генерация числа
	set @num = Rand() * (@hi - @lo) + @lo;

	-- вычисление на простоту числа
	set @result = dbo.IsPrime(@num);
	
	-- вывод результата
print(char(9) + N'║ ' + str(@i + 1, 2) + 
				N' ║ ' + str(@num, 10) + 
				N' ║ ' + iif(@result = 1, '    TRUE     ', '    FALSE    ') +
				N' ║');

	set @i += 1;
end;

-- вывод подвала таблицы
print(char(9) + N'╚════╩════════════╩═══════════════╝' + char(10));

go


-- •	Proc36. Описать функцию Fib(N) целого типа, вычисляющую N-й элемент последовательности 
--		чисел Фибоначчи FK, которая описывается следующими формулами:
--		F1 = 1, F2 = 1, FK = FK−2 + FK−1, K = 3, 4, ... 
--		Используя функцию Fib, найти пять чисел Фибоначчи с данными номерами N1, N2, . . ., N5.

-- создание функции
drop function if exists Fib;
go

create function Fib(@n int)
returns int
	begin

		-- переменные для вычисления
		declare @f1 int = 1, @f2 int = 1, @fk int = 1;

		-- счётчик итераций
		declare @i int = 1;

		while @i < @n begin
			
			-- число Фибоначчи
			set @fk = @f1 + @f2;
		
			-- установка значений для вычисления следующего числа
			set @f1 = @f2;
			set @f2 = @fk;

			set @i += 1;
		end;

		return @fk;
	end;
go

-- диапазон для генерации
declare @lo int = 1, @hi int = 15;

-- число Фибоначчи
declare @fib int;

-- номер числа Фибоначчи
declare @num int;

-- счётчик итераций
declare @i int = 0;

-- количество итераций
declare @n int = 5;

-- вывод шапки таблицы 
print(char(10) + 
	  char(9) + N'╔════╦═════════════╦═════════════════╗' + char(10) +
	  char(9) + N'║ N  ║ Номер числа ║ Число Фибоначчи ║' + char(10) + 
	  char(9) + N'╠════╬═════════════╬═════════════════╣');

-- обработка 
while @i < @n begin

	-- генерация числа
	set @num = Rand() * (@hi - @lo) + @lo;

	-- вычисление на простоту числа
	set @fib = dbo.Fib(@num);
	
	-- вывод результата
print(char(9) + N'║ ' + str(@i + 1, 2) + 
				N' ║ ' + str(@num, 11) + 
				N' ║ ' + str(@fib, 15) +
				N' ║');

	set @i += 1;
end;

-- вывод подвала таблицы
print(char(9) + N'╚════╩═════════════╩═════════════════╝' + char(10));

go
