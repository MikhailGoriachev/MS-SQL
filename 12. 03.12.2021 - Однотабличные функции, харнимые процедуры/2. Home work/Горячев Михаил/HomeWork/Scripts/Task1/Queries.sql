-- Proc3. 
-- Описать процедуру Mean(X, Y, AMean, GMean), вычисляющую
-- среднее арифметическое AMean = (X+Y)/2 и среднее геометрическое
-- GMean = Sqrt(Abs(X)·Abs(Y)) двух положительных чисел X и Y (X и Y — входные,
-- AMean и GMean — выходные параметры вещественного типа). С помощью
-- этой процедуры найти среднее арифметическое и среднее геометрическое
-- для пар (A, B), (A, C), (A, D), если даны A, B, C, D.

-- удаление процедуры
drop proc if exists Mean;
go

-- создание процедуры
create proc Mean 
	@x		float, 
	@y		float,
	@AMean	float out, 
	@GMean	float out 
as 
	begin
		set @AMean = (@x + @y) / 2;
		set @GMean = Sqrt(Abs(@x) * Abs(@y));
	end;
go

-- запрос для задачи Proc3

-- дипазон для генерации
declare @min int = 5, @max int = 15;

-- числа для обработки
declare @a float = rand() * (@max - @min) + @min,
		@b float = rand() * (@max - @min) + @min,
		@c float = rand() * (@max - @min) + @min,
		@d float = rand() * (@max - @min) + @min;

-- вывод условий задания
print(char(10) +
	N'  ╔═══════════════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                             Задание Proc3                             ║' + char(10) +
	N'  ╠═════════════════╦═════════════════════════════════════════════════════╣' + char(10) +
	N'  ║      Дано       ║                       Условия                       ║' + char(10) +
	N'  ╠═════════════════╬═════════════════════════════════════════════════════╣' + char(10) +
	N'  ║ A: ' + str(@a, 12, 5) + N' ║ Описать процедуру Mean(X, Y, AMean, GMean),         ║' + char(10) +
	N'  ║ B: ' + str(@b, 12, 5) + N' ║ вычисляющую среднее арифметическое AMean = (X+Y)/2  ║' + char(10) +
	N'  ║ C: ' + str(@c, 12, 5) + N' ║ и среднее геометрическое GMean = Sqrt(Abs(X)·Abs(Y))║' + char(10) +
	N'  ║ D: ' + str(@d, 12, 5) + N' ║ двух положительных чисел X и Y (X и Y — входные,    ║' + char(10) +
	N'  ║                 ║ AMean и GMean — выходные параметры вещественного    ║' + char(10) +
	N'  ║                 ║ типа). С помощью этой процедуры найти среднее       ║' + char(10) +
	N'  ║                 ║ арифметическое и среднее геометрическое для пар (A, ║' + char(10) +
	N'  ║                 ║ B), (A, C), (A, D), если даны A, B, C, D.           ║' + char(10) +
	N'  ╚═════════════════╩═════════════════════════════════════════════════════╝');


-- вывод шапки решения
print(char(10) +
	N'  ╔═══════════════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                                Решение                                ║' + char(10) +
    N'  ╠═════════════════╦═════════════════╦═════════════════╦═════════════════╣' + char(10) +
    N'  ║   Значение 1    ║   Значение 2    ║      AMean      ║      GMean      ║' + char(10) +
    N'  ╠═════════════════╬═════════════════╬═════════════════╬═════════════════╣');

declare @AMean float, @Gmean float;

-- вычисление для пары (A, B)
exec Mean @a, @b, @AMean out, @GMean out;
print(N'  ║ A:' + str(@a, 13, 5) + N' ║ B:' + str(@b, 13, 5) + N' ║ ' 
		+ str(@AMean, 15, 5) + N' ║ ' + str(@GMean, 15, 5) + N' ║');

-- вычисление для пары (B, C)
exec Mean @b, @c, @AMean out, @GMean out;
print(N'  ║ B:' + str(@b, 13, 5) + N' ║ C:' + str(@c, 13, 5) + N' ║ ' 
		+ str(@AMean, 15, 5) + N' ║ ' + str(@GMean, 15, 5) + N' ║');

-- вычисление для пары (C, D)
exec Mean @c, @d, @AMean out, @GMean out;
print(N'  ║ C:' + str(@c, 13, 5) + N' ║ D:' + str(@d, 13, 5) + N' ║ ' 
		+ str(@AMean, 15, 5) + N' ║ ' + str(@GMean, 15, 5) + N' ║');

-- вывод подвала таблицы
print(N'  ╚═════════════════╩═════════════════╩═════════════════╩═════════════════╝')

go


-- Proc4. 
-- Описать процедуру TrianglePS(a, P, S), вычисляющую по стороне a
-- равностороннего треугольника его периметр P = 3·a и площадь 
-- S = a^2·√(3)/4 (a — входной, P и S — выходные параметры; все 
-- параметры являются вещественными). С помощью этой процедуры найти
-- периметры и площади трех равносторонних треугольников с данными 
-- сторонами.

-- удаление процедуры
drop proc if exists TrianglePS;
go

-- создание процедуры 
create proc TrianglePS
	@a float, 
	@p float out, 
	@s float out
as
	begin
		-- вычисление периметра равностороннего треугольника
		set @p = 3 * @a;

		-- вычисление площади равностороннего треугольника
		set @s = (@a * @a) * sqrt(3)/4
	end;
go

-- запрос для задачи Proc4

-- дипазон для генерации
declare @min int = 5, @max int = 15;

-- числа для обработки
declare @a float = rand() * (@max - @min) + @min,
		@b float = rand() * (@max - @min) + @min,
		@c float = rand() * (@max - @min) + @min,
		@d float = rand() * (@max - @min) + @min;

-- вывод условий задания
print(char(10) +
	N'  ╔════════════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                           Задание Proc4                            ║' + char(10) +
	N'  ╠════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║                              Условия                               ║' + char(10) +
	N'  ╠════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║ Описать процедуру TrianglePS(a, P, S), вычисляющую по стороне a    ║' + char(10) +
	N'  ║ равностороннего треугольника его периметр P = 3·a и площадь        ║' + char(10) +
	N'  ║ S = a^2·√(3)/4 (a — входной, P и S — выходные параметры; все       ║' + char(10) +
	N'  ║ параметры являются вещественными). С помощью этой процедуры найти  ║' + char(10) +
	N'  ║ периметры и площади трех равносторонних треугольников с данными    ║' + char(10) +
	N'  ║ сторонами.                                                         ║' + char(10) +
	N'  ╚════════════════════════════════════════════════════════════════════╝');

-- вывод шапки решения
print(char(10) +
	N'  ╔══════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                         Решение                          ║' + char(10) +
    N'  ╠════╦═════════════════╦═════════════════╦═════════════════╣' + char(10) +
    N'  ║ N  ║     Сторона     ║  Периметр (P)   ║   Площадь (S)   ║' + char(10) +
    N'  ╠════╬═════════════════╬═════════════════╬═════════════════╣');

-- периметр и площадь
declare @p float, @s float;

-- количество и счётчик итераций 
declare @n int = 3, @i int = 0;

-- вычисления
while @i < @n begin

	-- генерация значения стороны
	set @a = rand() * (@max - @min) + @min;
	
	-- вычисление параметров треугольника 
	exec dbo.TrianglePS @a, @p out, @s out;

	-- вывод значений
	print(N'  ║ ' + str(@i + 1, 2) + N' ║ ' + str(@a, 15, 5) + N' ║ ' + str(@p, 15, 5) + N' ║ ' 
		+ str(@s, 15, 5) + N' ║ ');

	set @i += 1;
end;


-- вывод подвала таблицы
print(N'  ╚════╩═════════════════╩═════════════════╩═════════════════╝');
go


-- Proc7. 
-- Описать процедуру InvertDigits(K), меняющую порядок следования
-- цифр целого положительного числа K на обратный (K — параметр целого
-- типа, являющийся одновременно входным и выходным). С помощью этой
-- процедуры поменять порядок следования цифр на обратный для каждого
-- из пяти данных целых чисел.

-- удаление процедуры
drop proc InvertDigits;
go

-- создание процедуры
create proc InvertDigits
	@k int out
as
	begin

		-- копия числа 
		declare @n int = @k;

		-- обнуление исходного числа
		set @k = 0;

		-- изменение порядка цифр
		while @n > 0 begin
			set @k = @k * 10 + @n % 10;
			set @n /= 10;
		end;

	end;
go

-- демонстрация работы 

-- диапазон для генерации
declare @min int = 10000, @max int = 99999;

-- число для обработки
declare @num int;

-- количество и счётчик итераций
declare @i int = 0, @n int = 5;

-- перевёрнутое число
declare @rev int;

-- вывод условий задания
print(char(10) +
	N'  ╔═════════════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                            Задание Proc7                            ║' + char(10) +
	N'  ╠═════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║                               Условия                               ║' + char(10) +
	N'  ╠═════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║ Описать процедуру InvertDigits(K), меняющую порядок следования      ║' + char(10) +
	N'  ║ цифр целого положительного числа K на обратный (K — параметр целого ║' + char(10) +
	N'  ║ типа, являющийся одновременно входным и выходным). С помощью этой   ║' + char(10) +
	N'  ║ процедуры поменять порядок следования цифр на обратный для каждого  ║' + char(10) +
	N'  ║ из пяти данных целых чисел.                                         ║' + char(10) +
	N'  ╚═════════════════════════════════════════════════════════════════════╝');

-- вывод шапки решения
print(char(10) +
	N'  ╔════════════════════════════════════════╗' + char(10) +
	N'  ║                Решение                 ║' + char(10) +
    N'  ╠════╦═════════════════╦═════════════════╣' + char(10) +
    N'  ║ N  ║ Исходное число  ║  Перевёрнутое   ║' + char(10) +
    N'  ╠════╬═════════════════╬═════════════════╣');

-- обработка по заданию
while @i < @n begin

	-- генерация числа
	set @num = rand() * (@max - @min) + @min;

	-- переворот числа
	set @rev = @num;
	exec InvertDigits @rev out;

	-- вывод значений
	print(N'  ║ ' + str(@i + 1, 2) + N' ║ ' + str(@num, 15) + N' ║ ' + str(@rev, 15) 
	+ N' ║');

	set @i += 1;

end;

-- вывод подвала таблицы
print(N'  ╚════╩═════════════════╩═════════════════╝');
go


-- Proc8. 
-- Описать процедуру AddRightDigit(D, K), добавляющую к целому по-
-- ложительному числу K справа цифру D (D — входной параметр целого
-- типа, лежащий в диапазоне 0–9, K — параметр целого типа, являющийся
-- одновременно входным и выходным). С помощью этой процедуры после-
-- довательно добавить к данному числу K справа данные цифры D1 и D2,
-- выводя результат каждого добавления.

-- удаление процедуры 
drop proc AddRightDigit;
go

-- создание процедуры
create proc AddRightDigit
	@d int,
	@k int out
as 
	begin
		set @k = @k * 10 + @d;
	end;
go
	

-- демонстрация работы

-- диапазон для генерации
declare @min int = 1000, @max int = 9999;

-- число до и после обработки 
declare @num int = rand() * (@max - @min) + @min;
declare @result int = @num;

set @min = 0;
set @max = 9;

-- числа для добавления 
declare @d1 int = rand() * (@max - @min) + @min, @d2 int = rand() * (@max - @min) + @min;

-- вывод условия

-- вывод условий задания
print(char(10) +
	N'  ╔═════════════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                            Задание Proc8                            ║' + char(10) +
	N'  ╠═════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║                               Условия                               ║' + char(10) +
	N'  ╠═════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║ Описать процедуру AddRightDigit(D, K), добавляющую к целому по-     ║' + char(10) +
	N'  ║ ложительному числу K справа цифру D (D — входной параметр целого    ║' + char(10) +
	N'  ║ типа, лежащий в диапазоне 0–9, K — параметр целого типа, являющийся ║' + char(10) +
	N'  ║ одновременно входным и выходным). С помощью этой процедуры после-   ║' + char(10) +
	N'  ║ довательно добавить к данному числу K справа данные цифры D1 и D2,  ║' + char(10) +
	N'  ║ выводя результат каждого добавления.                                ║' + char(10) +
	N'  ╚═════════════════════════════════════════════════════════════════════╝');

-- вывод шапки решения
print(char(10) +
	N'  ╔═════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                           Решение                           ║' + char(10) +
    N'  ╠════╦══════════════════╦══════════════════╦══════════════════╣' + char(10) +
    N'  ║ N  ║ Цифра добавления ║  До добавления   ║ После добавления ║' + char(10) +
    N'  ╠════╬══════════════════╬══════════════════╬══════════════════╣');

-- добавление @d1 
exec AddRightDigit @d1, @result out;

-- вывод добавление @d1
print (N'  ║  1 ║ D1: ' + str(@d1, 12) + N' ║ ' + str(@num, 16) + N' ║ ' + str(@result, 16) + N' ║');

set @num = @result;

-- добавление @d2
exec AddRightDigit @d2, @result out;

-- вывод добавление @d2
print (N'  ║  2 ║ D2: ' + str(@d2, 12) + N' ║ ' + str(@num, 16) + N' ║ ' + str(@result, 16) + N' ║');

-- вывод подвала таблицы
print(N'  ╚════╩══════════════════╩══════════════════╩══════════════════╝');
go

-- Proc9. 
-- Описать процедуру AddLeftDigit(D, K), добавляющую к целому 
-- положительному числу K слева цифру D (D — входной параметр 
-- целого типа, лежащий в диапазоне 1–9, K — параметр целого 
-- типа, являющийся одновременно входным и выходным). С помощью 
-- этой процедуры последовательно добавить к данному числу 
-- K слева данные цифры D1 и D2, выводя результат каждого добавления.

-- удаление процедуры 
drop proc AddLeftDigit;
go

-- создание процедуры
create proc AddLeftDigit
	@d int,
	@k int out
as 
	begin
		
		-- количество цифр в числе
		declare @n int = 0;

		-- копия числа, для получения количества цифр в числе
		declare @temp int = @k;
				
		-- получение количества цифр в числе
		while @temp > 0 begin
			set @temp /= 10
			set @n += 1;
		end;

		-- умножения числа d так, чтоб при сложении передаваемая цифра встала слева
		while @n > 0 begin
			set @d *= 10;
			set @n -= 1;
		end;

		-- установка цифры d слева числа k
		set @k = @d + @k;

	end
go
	

-- демонстрация работы

-- диапазон для генерации
declare @min int = 1000, @max int = 9999;

-- число до и после обработки 
declare @num int = rand() * (@max - @min) + @min;
declare @result int = @num;

set @min = 0;
set @max = 9;

-- числа для добавления 
declare @d1 int = rand() * (@max - @min) + @min, @d2 int = rand() * (@max - @min) + @min;

-- вывод условия

-- вывод условий задания
print(char(10) +
	N'  ╔═════════════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                            Задание Proc9                            ║' + char(10) +
	N'  ╠═════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║                               Условия                               ║' + char(10) +
	N'  ╠═════════════════════════════════════════════════════════════════════╣' + char(10) +
	N'  ║ Описать процедуру AddLeftDigit(D, K), добавляющую к целому          ║' + char(10) +
	N'  ║ положительному числу K слева цифру D (D — входной параметр          ║' + char(10) +
	N'  ║ целого типа, лежащий в диапазоне 1–9, K — параметр целого           ║' + char(10) +
	N'  ║ типа, являющийся одновременно входным и выходным). С помощью        ║' + char(10) +
	N'  ║ этой процедуры последовательно добавить к данному числу             ║' + char(10) +
	N'  ║ K слева данные цифры D1 и D2, выводя результат каждого добавления.  ║' + char(10) +
	N'  ╚═════════════════════════════════════════════════════════════════════╝');

-- вывод шапки решения
print(char(10) +
	N'  ╔═════════════════════════════════════════════════════════════╗' + char(10) +
	N'  ║                           Решение                           ║' + char(10) +
    N'  ╠════╦══════════════════╦══════════════════╦══════════════════╣' + char(10) +
    N'  ║ N  ║ Цифра добавления ║  До добавления   ║ После добавления ║' + char(10) +
    N'  ╠════╬══════════════════╬══════════════════╬══════════════════╣');

-- добавление @d1 
exec AddLeftDigit @d1, @result out;

-- вывод добавление @d1
print (N'  ║  1 ║ D1: ' + str(@d1, 12) + N' ║ ' + str(@num, 16) + N' ║ ' + str(@result, 16) + N' ║');

set @num = @result;

-- добавление @d2
exec AddLeftDigit @d2, @result out;

-- вывод добавление @d2
print (N'  ║  2 ║ D2: ' + str(@d2, 12) + N' ║ ' + str(@num, 16) + N' ║ ' + str(@result, 16) + N' ║');

-- вывод подвала таблицы
print(N'  ╚════╩══════════════════╩══════════════════╩══════════════════╝');
go
